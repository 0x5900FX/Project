from app import db
from werkzeug.security import generate_password_hash, check_password_hash


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    role = db.Column(db.String(20), nullable=False)  # admin, seller, buyer
    password_hash = db.Column(db.String(128), nullable=False)  # new field
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Property(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(120), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(db.Float, nullable=False)
    seller_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    image_url = db.Column(db.String(255), nullable=True)
    seller = db.relationship("User", backref="properties")
    docs_url = db.Column(db.String(200))  # uploaded document for verification
    verified = db.Column(db.Boolean, default=False)  # verification status

# app/property_routes.py
from flask import Blueprint, request, current_app, jsonify
from werkzeug.utils import secure_filename
from app.models import Property
from app import db
from app.utils import token_required, role_required
import os

ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}

property_bp = Blueprint("properties", __name__, url_prefix="/properties")

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

# ---------------- LIST PROPERTIES ----------------
@property_bp.route("", methods=["GET"])
@token_required
def list_properties():
    properties = Property.query.filter_by(verified=True).all()
    return {
        "properties": [
            {
                "id": p.id,
                "title": p.title,
                "description": p.description,
                "price": p.price,
                "seller_id": p.seller_id,
                "image_url": p.image_url,
                "verified": p.verified,
                "docs_url": p.docs_url
            } for p in properties
        ]
    }

# ---------------- CREATE PROPERTY ----------------
@property_bp.route("", methods=["POST"])
@token_required
@role_required("admin", "seller")
def create_property():
    data = request.get_json()
    if not data or not all(k in data for k in ("title", "price")):
        return {"error": "title and price are required"}, 400

    new_property = Property(
        title=data["title"],
        description=data.get("description", ""),
        price=data["price"],
        image_url=data.get("image_url"),
        seller_id=request.user.id
    )
    db.session.add(new_property)
    db.session.commit()

    return {
        "id": new_property.id,
        "title": new_property.title,
        "description": new_property.description,
        "price": new_property.price,
        "seller_id": new_property.seller_id
    }, 201

# ---------------- UPDATE PROPERTY ----------------
@property_bp.route("/<int:property_id>", methods=["PUT"])
@token_required
@role_required("admin", "seller", check_ownership=True)
def update_property(property_id):
    prop = Property.query.get(property_id)
    if not prop:
        return {"error": "Property not found"}, 404

    data = request.get_json()
    if not data:
        return {"error": "No data provided"}, 400

    prop.title = data.get("title", prop.title)
    prop.description = data.get("description", prop.description)
    prop.price = data.get("price", prop.price)
    prop.image_url = data.get("image_url", prop.image_url)

    db.session.commit()
    return {
        "id": prop.id,
        "title": prop.title,
        "description": prop.description,
        "price": prop.price,
        "seller_id": prop.seller_id
    }

# ---------------- DELETE PROPERTY ----------------
@property_bp.route("/<int:property_id>", methods=["DELETE"])
@token_required
@role_required("admin", "seller", check_ownership=True)
def delete_property(property_id):
    prop = Property.query.get(property_id)
    if not prop:
        return {"error": "Property not found"}, 404

    db.session.delete(prop)
    db.session.commit()
    return {"message": f"Property {property_id} deleted"}

# ---------------- UPLOAD PROPERTY IMAGE ----------------
@property_bp.route("/<int:property_id>/upload_image", methods=["POST"])
@token_required
@role_required("seller", check_ownership=True)
def upload_image(property_id):
    prop = Property.query.get(property_id)
    if not prop:
        return {"error": "Property not found"}, 404

    if "file" not in request.files:
        return {"error": "No file part"}, 400

    file = request.files["file"]
    if file.filename == "":
        return {"error": "No selected file"}, 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(current_app.config["UPLOAD_FOLDER_IMAGES"], filename))
        prop.image_url = f"/uploads/images/{filename}"
        db.session.commit()
        return {"image_url": prop.image_url}, 201

    return {"error": "File type not allowed"}, 400

# ---------------- UPLOAD VERIFICATION DOCS ----------------
@property_bp.route("/<int:property_id>/upload_docs", methods=["POST"])
@token_required
@role_required("seller", check_ownership=True)
def upload_docs(property_id):
    prop = Property.query.get(property_id)
    if not prop:
        return {"error": "Property not found"}, 404

    if "file" not in request.files:
        return {"error": "No file part"}, 400

    file = request.files["file"]
    if file.filename == "":
        return {"error": "No selected file"}, 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(current_app.config["UPLOAD_FOLDER_DOCS"], filename))
        prop.docs_url = f"/uploads/docs/{filename}"
        prop.verified = False  # reset verification when new doc uploaded
        db.session.commit()
        return {"docs_url": prop.docs_url, "verified": prop.verified}, 201

    return {"error": "File type not allowed"}, 400

# ---------------- ADMIN VERIFY PROPERTY ----------------
@property_bp.route("/<int:property_id>/verify", methods=["PUT"])
@token_required
@role_required("admin")
def verify_property(property_id):
    prop = Property.query.get(property_id)
    if not prop:
        return {"error": "Property not found"}, 404

    data = request.get_json()
    if not data or "verified" not in data:
        return {"error": "Verified status required"}, 400

    prop.verified = bool(data["verified"])
    db.session.commit()
    status = "verified" if prop.verified else "unverified"
    return {"message": f"Property {property_id} is now {status}"}
from flask import Blueprint, request, jsonify
from app.models import User
from app import db
from app.utils import role_required, token_required, generate_token

bp = Blueprint("api", __name__)

# ------------------- USERS -------------------

@bp.route("/users")
@token_required
@role_required("admin")  # Only admin can list users
def list_users():
    users = User.query.all()
    return {
        "users": [
            {"id": u.id, "username": u.username, "email": u.email, "role": u.role}
            for u in users
        ]
    }

@bp.route("/users", methods=["POST"])
def create_user():
    data = request.get_json()
    if not data or not all(k in data for k in ("username", "email", "role", "password")):
        return {"error": "username, email, role, and password are required"}, 400

    if User.query.filter_by(username=data["username"]).first():
        return {"error": "Username already exists"}, 400

    new_user = User(
        username=data["username"],
        email=data["email"],
        role=data["role"]
    )
    new_user.set_password(data["password"])
    db.session.add(new_user)
    db.session.commit()

    return {
        "id": new_user.id,
        "username": new_user.username,
        "email": new_user.email,
        "role": new_user.role
    }, 201

@bp.route("/users/<int:user_id>", methods=["DELETE"])
@token_required
@role_required("admin")
def delete_user(user_id):
    user = User.query.get(user_id)
    if not user:
        return {"error": "User not found"}, 404
    db.session.delete(user)
    db.session.commit()
    return {"message": f"User {user_id} deleted"}

@bp.route("/users/<int:user_id>/password", methods=["PUT"])
@token_required
def change_password(user_id):
    user = User.query.get(user_id)
    if not user:
        return {"error": "User not found"}, 404

    # Only the user themselves or an admin can change the password
    if request.user.id != user.id and request.user.role != "admin":
        return {"error": "Permission denied"}, 403

    data = request.get_json()
    if not data or "new_password" not in data:
        return {"error": "New password required"}, 400

    user.set_password(data["new_password"])
    db.session.commit()

    return {"message": "Password updated successfully"}

# ------------------- LOGIN -------------------

@bp.route("/login", methods=["POST"])
def login():
    data = request.get_json()
    if not data or not all(k in data for k in ("username", "password")):
        return {"error": "username and password are required"}, 400

    user = User.query.filter_by(username=data["username"]).first()
    if not user or not user.check_password(data["password"]):
        return {"error": "Invalid username or password"}, 401

    token = generate_token(user)
    return {"token": token}
from functools import wraps
from flask import request, jsonify, current_app
from app.models import User
import base64
from datetime import datetime, timedelta
import jwt


def basic_auth_required(f):
    """
    Decorator to enforce HTTP Basic Authentication.
    Attaches the authenticated user to request.user
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        auth = request.headers.get("Authorization")
        if not auth or not auth.startswith("Basic "):
            return jsonify({"error": "Missing or invalid Authorization header"}), 401
        try:
            b64_credentials = auth.split(" ")[1]
            decoded = base64.b64decode(b64_credentials).decode("utf-8")
            username, password = decoded.split(":")
        except Exception:
            return jsonify({"error": "Invalid authentication"}), 401

        user = User.query.filter_by(username=username).first()
        if not user or not user.check_password(password):
            return jsonify({"error": "Invalid username or password"}), 401

        request.user = user  # Attach user to request
        return f(*args, **kwargs)
    return wrapper


def role_required(*allowed_roles, check_ownership=False):
    """
    Decorator to enforce role-based access and optional ownership for properties.
    Usage:
        @role_required("admin") -> only admin
        @role_required("seller", check_ownership=True) -> seller can access only their own resource
    """
    from app.models import Property  # imported here to avoid circular import

    def decorator(f):
        @wraps(f)
        @token_required  # ensures request.user is available
        def wrapper(*args, **kwargs):
            user = getattr(request, "user", None)
            if not user or user.role not in allowed_roles:
                return jsonify({"error": "Forbidden: insufficient role"}), 403

            if check_ownership:
                property_id = kwargs.get("property_id")
                if not property_id:
                    return jsonify({"error": "Resource ID not provided"}), 400

                prop = Property.query.get(property_id)
                if not prop:
                    return jsonify({"error": "Property not found"}), 404

                if prop.seller_id != user.id and user.role != "admin":
                    return jsonify({"error": "Forbidden: not the owner"}), 403

            return f(*args, **kwargs)
        return wrapper
    return decorator


def generate_token(user, expires_in=3600):
    """
    Generate JWT token for a user.
    :param user: User object
    :param expires_in: Expiration time in seconds (default 1 hour)
    """
    payload = {
        "user_id": user.id,
        "exp": datetime.now() + timedelta(seconds=expires_in),
        "role": user.role,  # include role
    }
    token = jwt.encode(payload, current_app.config["SECRET_KEY"], algorithm="HS256")
    return token


def token_required(f):
    """
    Decorator to enforce JWT token authentication.
    Use 'Authorization: Bearer <token>' in headers.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]

        if not token:
            return jsonify({"error": "Token is missing"}), 401

        try:
            data = jwt.decode(token, current_app.config["SECRET_KEY"], algorithms=["HS256"])
            user = User.query.get(data["user_id"])
            if not user:
                raise Exception("User not found")
            request.user = user
        except Exception:
            return jsonify({"error": "Token is invalid or expired"}), 401

        return f(*args, **kwargs)
    return decorated
# app/__init__.py
import os
from flask import Flask, send_from_directory
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from dotenv import load_dotenv
from flask_cors import CORS  # import CORS here

db = SQLAlchemy()
migrate = Migrate()

def create_app():
    load_dotenv()
    app = Flask(__name__)

    # ---------------- CONFIG ----------------
    app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv(
        "DATABASE_URL", "sqlite:///dev.db"
    )
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    app.config["SECRET_KEY"] = os.getenv("SECRET_KEY", "supersecretkey")

    # ---------------- UPLOAD FOLDERS ----------------
    IMAGE_UPLOAD_FOLDER = os.path.join(os.getcwd(), "uploads", "images")
    DOCS_UPLOAD_FOLDER = os.path.join(os.getcwd(), "uploads", "docs")
    os.makedirs(IMAGE_UPLOAD_FOLDER, exist_ok=True)
    os.makedirs(DOCS_UPLOAD_FOLDER, exist_ok=True)

    app.config["UPLOAD_FOLDER_IMAGES"] = IMAGE_UPLOAD_FOLDER
    app.config["UPLOAD_FOLDER_DOCS"] = DOCS_UPLOAD_FOLDER

    # ---------------- INIT EXTENSIONS ----------------
    db.init_app(app)
    migrate.init_app(app, db)

    # ---------------- ROUTES ----------------
    from app.routes import bp as user_bp
    from app.property_routes import property_bp

    app.register_blueprint(user_bp)
    app.register_blueprint(property_bp)

    # ---------------- SERVE UPLOADED FILES ----------------
    @app.route("/uploads/images/<filename>")
    def uploaded_image(filename):
        return send_from_directory(app.config["UPLOAD_FOLDER_IMAGES"], filename)

    @app.route("/uploads/docs/<filename>")
    def uploaded_doc(filename):
        return send_from_directory(app.config["UPLOAD_FOLDER_DOCS"], filename)

    @app.route("/")
    def index():
        return {"message": "API is running"}

    # ----------------- ENABLE CORS ------------------
    CORS(app)  # apply CORS to the same app, do NOT create a new app

    return app
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)
